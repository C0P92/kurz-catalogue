import { MouseEventHandler } from "./MouseEventHandler.js";
/**
 * The inner HTML of the container element.
 *
 * The first inner div contains the iFrame and the second inner div the label
 * ui. The last one is for the loading ui.
 */
const CONTAINER_INNER_HTML = `
<div style="position: relative; height: 100%; width: 100%; overflow: hidden;">
  <div style="height: 100%; width: 100%;"></div>
  <div style="position: absolute; top: 0; right: 0; width: 100%; height: 100%; pointer-events: none;"></div>
  <div style="position: absolute; top: 0; right: 0; width: 100%; height: 100%; pointer-events: none;"></div>
</div>
`;
const ACKABLE_CHANNELS = [
    "set-environment",
    "set-layers",
    "set-geometry",
    "set-embossing-height-texture",
    "set-cutout-texture",
    "set-outer-contour",
    "set-surface-material",
    "download-screenshot",
];
export class DcController {
    /** @internal */
    constructor(container, options) {
        /**
         * A map that stores messages that should be send to the engine once the
         * iframe has been created.
         */
        this.messageQueue = new Map();
        /**
         * A promise that resolves once the engine is ready.
         *
         * @internal
         */
        this.engineReadyPromise = new Promise((resolve) => {
            this.engineReadyResolve = resolve;
        });
        /**
         * Whether or not the engine is ready.
         *
         * @internal
         */
        this.engineReady = false;
        /**
         * A list with externally registered listeners for engine messages.
         *
         * The key is the channel and the value are the listeners that are registered
         * for that channel.
         */
        this.listeners = new Map();
        /**
         * Event handler for passing mouse events from the embedder to the engine.
         */
        this.mouseEventHandler = new MouseEventHandler(this);
        /**
         * A map with the nonce as the key and a function that accepts the ack message
         * for the nonce as the value.
         */
        this.waitingForAck = new Map();
        /**
         * Listens for when the engine gets loaded.
         *
         * @internal
         */
        this.onLoad = (callback) => this.addListener("library-load", callback);
        /**
         * Listens for when the engine gets unloaded.
         *
         * @internal
         */
        this.onUnload = (callback) => this.addListener("library-unload", callback);
        this.id = Math.random().toString(36).substring(2);
        this.container = container;
        this.container.innerHTML = CONTAINER_INNER_HTML;
        this.innerContainer = this.container.children[0];
        this.iFrameContainer = this.innerContainer.children[0];
        this.tagUiContainer = this.innerContainer.children[1];
        this.loadingUiContainer = this.innerContainer.children[2];
        this.baseUrl = options.baseUrl;
        this.accessToken = options.accessToken;
        this.addListener("engine-ready", this.handleEngineReady.bind(this));
        this.addListener("pointer-event", this.mouseEventHandler.handlePointerEvent.bind(this.mouseEventHandler));
        this.addListener("ack", this.handleAck.bind(this));
        this.addEventListener();
    }
    /**
     * Creates the iFrame element that is used to embed Dreamcomposer.
     */
    async createIFrame() {
        this.iFrameContainer.innerHTML =
            "<iframe" +
                ' frameborder="0"' +
                ' title="Dreamcomposer"' +
                " allowfullscreen" +
                ' style="width: 100%; height: 100%; color-scheme: auto;"' +
                "></iframe>";
        this.iframe = this.iFrameContainer.querySelector("iframe");
        this.iframe.src = `${this.baseUrl.embed}/embed/?${this.accessToken}`;
    }
    /**
     * Registers an event listener for engine messages.
     */
    addEventListener() {
        window.addEventListener("message", (event) => {
            var _a;
            if (!this.iframe ||
                event.origin !== this.baseUrl.embed ||
                event.source !== ((_a = this.iframe) === null || _a === void 0 ? void 0 : _a.contentWindow)) {
                return;
            }
            const message = event.data;
            this.callListener(message.channel, message);
        });
    }
    /**
     * Calls a listener that was registered with the `on` method.
     */
    callListener(channel, payload) {
        const listeners = this.listeners.get(channel);
        for (const listener of listeners !== null && listeners !== void 0 ? listeners : []) {
            try {
                listener(payload);
            }
            catch (error) {
                console.error("Listener call failed", error);
            }
        }
    }
    handleEngineReady(event) {
        if (event.payload) {
            this.engineReadyResolve();
            this.engineReady = true;
        }
    }
    handleAck(event) {
        const callback = this.waitingForAck.get(event.payload.nonce);
        if (callback) {
            callback(event);
            this.waitingForAck.delete(event.payload.nonce);
        }
    }
    /**
     * Sets the render function that should be used to render the preview.
     */
    setPreviewRenderer(renderer) {
        this.previewRenderer = renderer;
        this.renderPreview();
    }
    /**
     * Renders the preview if the engine is not loaded and a render function is
     * available.
     */
    renderPreview() {
        if (!this.isLoaded() && this.previewRenderer) {
            this.previewRenderer(this.iFrameContainer);
        }
    }
    /**
     * Loads the iFrame if it hasn't been loaded yet.
     *
     * @internal
     */
    async load() {
        if (!this.iframe) {
            this.createIFrame();
            this.callListener("library-load", null);
            const promises = [];
            for (const message of this.messageQueue.values()) {
                promises.push(this.engineReadyPromise.then(() => {
                    this.iframe.contentWindow.postMessage(message, this.baseUrl.embed);
                }));
            }
            await Promise.all(promises);
            this.mouseEventHandler.addListeners();
        }
    }
    /**
     * Loads the iFrame if it hasn't been loaded yet.
     *
     * @internal
     */
    unload() {
        if (this.iframe) {
            this.iframe.remove();
            this.iframe = undefined;
            this.iFrameContainer.innerHTML = "";
            this.callListener("library-unload", null);
            this.engineReady = false;
            this.engineReadyPromise = new Promise((resolve) => {
                this.engineReadyResolve = resolve;
            });
            this.renderPreview();
        }
        this.mouseEventHandler.removeListeners();
    }
    /**
     * Checks if the engine is loaded.
     *
     * @returns Whether or not the engine is loaded.
     */
    isLoaded() {
        return !!this.iframe;
    }
    /**
     * Listens for messages from the engine.
     *
     * @param channel The channel to listen on.
     * @param callback The listener that gets called when a message on that
     *                 channel is received.
     * @internal
     */
    addListener(channel, callback) {
        if (!this.listeners.has(channel)) {
            this.listeners.set(channel, []);
        }
        this.listeners.get(channel).push(callback);
        return () => this.removeListener(channel, callback);
    }
    /**
     * Unregisters the given listener that was registered with the `on` method.
     *
     * @param channel The channel that the listener was registered on.
     * @param callback The callback function that was registered.
     * @internal
     */
    removeListener(channel, callback) {
        const listeners = this.listeners.get(channel);
        if (listeners) {
            const index = listeners.indexOf(callback);
            if (index !== -1) {
                listeners.splice(index, 1);
            }
        }
    }
    /**
     * Posts a message to the iframe once the engine is ready.
     *
     * @param message The message without the nonce. The nonce is automatically
     *                added by the controller.
     * @params options Options for the method.
     * @returns A promise that resolves once the message has been acked by the
     *          engine. If something went wrong, the promise is rejected with an
     *          error message.
     * @internal
     */
    async postMessage(message, options = { memorize: true }) {
        const nonce = Math.random().toString(16).substring(2);
        const noncedMessage = { ...message, nonce };
        if (this.iframe) {
            this.engineReadyPromise.then(() => {
                this.iframe.contentWindow.postMessage(noncedMessage, this.baseUrl.embed);
            });
        }
        if (options.memorize) {
            this.messageQueue.set(message.channel, noncedMessage);
        }
        if (ACKABLE_CHANNELS.includes(message.channel)) {
            // We wait for the ack and once it's received, we resolve the promise.
            return new Promise((resolve, reject) => {
                this.waitingForAck.set(nonce, (ackMessage) => {
                    if (ackMessage.payload.error) {
                        reject(ackMessage.payload.error);
                    }
                    else {
                        resolve();
                    }
                });
            });
        }
        return Promise.resolve();
    }
}
