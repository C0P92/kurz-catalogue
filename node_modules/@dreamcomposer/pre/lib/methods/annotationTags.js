const unmountFunctions = new Map();
export async function setAnnotationTags(dcController, tags, renderLabel) {
    const tagsWithIDs = tags.map((t) => {
        const mappedTag = { ...t };
        if (mappedTag.id == null) {
            mappedTag.id = `${Math.random().toString(16).substring(2)}`;
        }
        return mappedTag;
    });
    const tagIds = tagsWithIDs.map((t) => t.id);
    const uniqueTagIds = new Set(tagIds);
    if (tagIds.length !== uniqueTagIds.size) {
        throw new Error("Annotation tag IDs must be unique.");
    }
    createAnnotationTagContainers(dcController, tagsWithIDs, renderLabel);
    const promise = dcController.postMessage({
        channel: "set-annotation-tags",
        payload: tagsWithIDs,
    });
    dcController.addListener("annotation-tag-position-changed", (msg) => updateAnnotationTagPositions(dcController, msg.payload));
    return promise;
}
function getAnnotationTagDivId(dcController, tag) {
    return `dc-${dcController.id}-annotation-tag-${tag.id}`;
}
/**
 * Creates a unique DIV for each tag and renders the tag inside it.
 */
function createAnnotationTagContainers(dcController, tags, renderTag) {
    if (unmountFunctions.has(dcController)) {
        unmountFunctions.get(dcController).forEach((fn) => fn());
        unmountFunctions.delete(dcController);
    }
    const tagDivs = Array.from(dcController.tagUiContainer.querySelectorAll(".dc-annotation-tag"));
    const unmountFunctionsForThisController = [];
    tags.forEach((l) => {
        const divId = getAnnotationTagDivId(dcController, l);
        let div = tagDivs.find((div) => div.id === divId);
        if (div == null) {
            div = document.createElement("div");
            div.id = divId;
            div.className = "dc-annotation-tag";
            div.style.position = "absolute";
            div.style.top = "0";
            div.style.left = "0";
            div.style.userSelect = "none";
            div.style.display = "none";
            dcController.tagUiContainer.appendChild(div);
            tagDivs.push(div);
        }
        div.innerHTML = "";
        const unmount = renderTag(l, div);
        if (typeof unmount === "function") {
            unmountFunctionsForThisController.push(unmount);
        }
    });
    unmountFunctions.set(dcController, unmountFunctionsForThisController);
    // Delete unused tag DIVs
    tagDivs.forEach((div) => {
        if (!tags.some((l) => div.id === getAnnotationTagDivId(dcController, l))) {
            div.remove();
        }
    });
}
/**
 * Updates the style properties of the DIVs to position them at the desired
 * location
 */
function updateAnnotationTagPositions(dcController, tags) {
    const containerRect = dcController.tagUiContainer.getBoundingClientRect();
    tags.sort((a, b) => b.depth - a.depth);
    tags.forEach((t, idx) => {
        const div = dcController.tagUiContainer.querySelector(`#${getAnnotationTagDivId(dcController, t.tag)}`);
        if (div == null) {
            return;
        }
        const rect = div.getBoundingClientRect();
        let x = t.tagAnchorPosition.screenPosition.x * containerRect.width;
        const y = t.tagAnchorPosition.screenPosition.y * containerRect.height -
            rect.height / 2;
        // If the tag is on the left side of the anchor, move it to the left
        if (t.tagAnchorPosition.screenPosition.x <
            t.objectAnchorPosition.screenPosition.x) {
            x -= rect.width;
        }
        div.style.display = "block";
        div.style.transform = `translate(${x}px, ${y}px)`;
        div.style.zIndex = `${idx + 1}`;
    });
}
