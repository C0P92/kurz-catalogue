import { getGeometryById, isPcmGeometry } from "../pcm/geometry.js";
import { ensureCallOrder } from "../util/ensure-call-order.js";
export async function setGeometry(dcController, dataOrUrlOrIdOrPcm, options) {
    __setGeometry(dcController, dataOrUrlOrIdOrPcm, options);
}
const __setGeometry = ensureCallOrder(_setGeometry);
export async function _setGeometry(dcController, dataOrUrlOrIdOrPcm, options) {
    var _a, _b, _c;
    const stages = {};
    (_a = options === null || options === void 0 ? void 0 : options.stages) === null || _a === void 0 ? void 0 : _a.forEach((stage) => {
        if (stages[stage.name]) {
            throw new Error("Stage names must be unique");
        }
        stages[stage.name] = {
            name: stage.name,
            normalVector: [0, 0, 1],
            tris: [],
            uvColor: stage.uvColor,
            axes: stage.axes,
        };
    });
    if (isPcmGeometry(dataOrUrlOrIdOrPcm)) {
        const preset = options != null && "preset" in options ? options["preset"] : undefined;
        const presetOverrides = convertGeometryPresetToGeometryOverrides(preset, dataOrUrlOrIdOrPcm);
        if (options == null) {
            options = {};
        }
        options = {
            ...options,
            overrides: presetOverrides.concat(options.overrides || []),
        };
    }
    if (isPcmGeometry(dataOrUrlOrIdOrPcm)) {
        // PcmGeometry -> get the gltf URL
        return _setGeometry(dcController, dataOrUrlOrIdOrPcm.url, {
            ...dataOrUrlOrIdOrPcm,
            ...options,
        });
    }
    else if (typeof dataOrUrlOrIdOrPcm === "string") {
        // PCM id -> download the PcmGeometry
        if (!dataOrUrlOrIdOrPcm.startsWith("http")) {
            const geometry = await getGeometryById(dataOrUrlOrIdOrPcm, dcController.accessToken, dcController.baseUrl.pcm);
            if (!geometry) {
                throw new Error(`Cannot find geometry with id ${dataOrUrlOrIdOrPcm}. If you wanted ` +
                    `to load a geometry from a URL, please also provide the protocol ` +
                    `(i.e., "http(s)://").`);
            }
            return _setGeometry(dcController, geometry, options);
        }
    }
    // URL or Blob -> Send it to the engine
    await dcController.postMessage({
        channel: "set-geometry",
        payload: {
            model: dataOrUrlOrIdOrPcm,
            config: {
                defaultScale: (_b = options === null || options === void 0 ? void 0 : options.defaultScale) !== null && _b !== void 0 ? _b : [1, 1, 1],
                scaleWithMapping: (_c = options === null || options === void 0 ? void 0 : options.scaleWithMapping) !== null && _c !== void 0 ? _c : false,
                stages,
                // TODO Remove from engine. This should be decided by the user.
                useCutoutTexture: true,
                overrides: options === null || options === void 0 ? void 0 : options.overrides,
            },
        },
    });
}
function convertGeometryPresetToGeometryOverrides(preset, geometry) {
    const overrideConfig = geometry.overrideConfig;
    let createResetOverrides = true;
    let overrides = [];
    if (overrideConfig == null || overrideConfig.propertyOverrides == null) {
        return overrides; //geometry has no override configuration
    }
    if (overrideConfig.presets) {
        const presetId = preset || overrideConfig.defaultPreset || "";
        const presetData = overrideConfig.presets.find((p) => p.id === presetId);
        if (presetData) {
            createResetOverrides = false;
            presetData.components.forEach((component) => {
                const property = overrideConfig.propertyOverrides.find((prop) => prop.id === component.property);
                if (property) {
                    const option = property.options.find((option) => option.id === component.selection);
                    if (option) {
                        overrides.push({ target: property.target, data: option.data });
                    }
                }
            });
        }
    }
    if (createResetOverrides) {
        overrides = overrideConfig.propertyOverrides.map((property) => ({
            target: property.target,
            data: [],
        }));
    }
    return overrides.flat();
}
