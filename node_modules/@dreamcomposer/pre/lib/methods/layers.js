import { getMaterialById, isPcmMaterialMinimalData, } from "../pcm/material.js";
import { getPatternEmbossingById, } from "../pcm/pattern-embossing.js";
import { ensureCallOrder } from "../util/ensure-call-order.js";
import { parseColorHex } from "../util/parseColorHex.js";
/**
 * Sets the layers.
 *
 * @param dcController The DcController object obtained from the init function.
 * @param layers An array with layers. Layer objects later in the array overlay
 *               the layers that come before them.
 * @returns A promise that resolves when the layers have been set.
 */
export const setLayers = ensureCallOrder(_setLayers);
export async function _setLayers(dcController, layers) {
    const payload = {};
    await Promise.all(layers.map(async (layer, index) => {
        var _a, _b, _c, _d, _e, _f;
        const layerName = (_a = layer.name) !== null && _a !== void 0 ? _a : generateRandomLayerName();
        if (payload[layerName]) {
            throw new Error("Layer names must be unique.");
        }
        if (layer.overprintColor && !parseColorHex(layer.overprintColor)) {
            throw new Error("overprintColor must be a valid HEX color.");
        }
        const material = await getPcmMaterialWithDefinition(dcController, layer.material);
        if (material.isSurfaceMaterial) {
            throw new Error(`Material of layer ${index} is a surface material and cannot be used for layers.`);
        }
        if (layer.overprintContent && !material.supportsOverprintContent) {
            throw new Error(`Material of layer ${index} does not support 'overprintContent'.${material.isPrintingMaterial
                ? " It is a printed material on which the texture is always drawn by default."
                : ""}`);
        }
        if (layer.overprintColor && !material.supportsOverprintColor) {
            throw new Error(`Material of layer ${index} does not support 'overprintColor'.`);
        }
        let patternEmbossingPreset = (_b = layer.patternEmbossing) === null || _b === void 0 ? void 0 : _b.preset;
        if (typeof patternEmbossingPreset === "string") {
            const pcmPatternEmbossing = await getPatternEmbossingById(patternEmbossingPreset, dcController.accessToken, dcController.baseUrl.pcm);
            if (!pcmPatternEmbossing) {
                throw new Error(`Cannot find pattern embossing preset with id ${patternEmbossingPreset}`);
            }
            patternEmbossingPreset = pcmPatternEmbossing;
        }
        if (((_c = layer.patternEmbossing) === null || _c === void 0 ? void 0 : _c.preset) &&
            !material.supportsPatternEmbossing) {
            throw new Error(`Material of layer ${index} does not support 'patternEmbossing'.`);
        }
        payload[layerName] = {
            order: index,
            material: material.definition,
            visible: (_d = layer.visible) !== null && _d !== void 0 ? _d : true,
            texture: layer.texture,
            overprintContent: layer.overprintContent || material.isPrintingMaterial,
            overprintColor: layer.overprintColor,
            overprintMode: material.overprintMode === "none"
                ? undefined
                : material.overprintMode,
            patternEmbossing: layer.patternEmbossing && patternEmbossingPreset
                ? {
                    offset: (_e = layer.patternEmbossing.offset) !== null && _e !== void 0 ? _e : [0, 0],
                    overrides: patternEmbossingPreset.overrides,
                    rotation: (_f = layer.patternEmbossing.rotation) !== null && _f !== void 0 ? _f : 0,
                }
                : undefined,
        };
    }));
    return dcController.postMessage({ channel: "set-layers", payload });
}
function generateRandomLayerName() {
    return `layer-${Math.random().toString(16).substring(2)}`;
}
/**
 * Takes a material in various representations (id, pcm material) and returns
 * the corresponding pcm material with its definition.
 *
 * @internal
 */
export async function getPcmMaterialWithDefinition(dcController, material) {
    if (isPcmMaterialMinimalData(material)) {
        return material;
    }
    else {
        const pcmMaterial = await getMaterialById(material, dcController.accessToken, dcController.baseUrl.pcm);
        if (!pcmMaterial) {
            throw new Error(`Cannot find material with id ${material}`);
        }
        return pcmMaterial;
    }
}
