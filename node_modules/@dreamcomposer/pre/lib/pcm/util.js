import { validate as uuidValidate } from "uuid";
let doNotSendAccessTokenToPcm = false;
/**
 * Disabled the PCM check for the access token.
 *
 * This is a temporary option to bypass the access token check and get all items
 * from the PCM. It will be removed in the future and the access token will be
 * required by the PCM backend.
 */
export function disablePcmAccessTokenCheck() {
    doNotSendAccessTokenToPcm = true;
}
/**
 * @internal
 * Fetches data from the PCM.
 *
 * @param url The url for the request.
 * @param accessToken The access token of the application.
 * @returns The response.
 */
export const fetchPcmData = (url, accessToken) => fetch(url, {
    headers: {
        ...(doNotSendAccessTokenToPcm
            ? {}
            : { "dc-application-access-token": accessToken }),
    },
});
/**
 * Checks that the given access token is not undefined.
 */
export function checkAccessToken(accessToken) {
    if (accessToken === undefined) {
        throw new Error("You have to provide an access token either by setting a default one " +
            "with dc.setAccessToken(...) or by providing it directly.");
    }
}
const itemCache = new Map();
/**
 * Get a list with all PCM items of the given type.
 *
 * @param type The item type, used in the url.
 * @returns A list with the native PCM items.
 */
export async function _getPcmItems(type, accessToken, baseUrl) {
    checkAccessToken(accessToken);
    const keyMultiple = accessToken + "|" + type + "|" + baseUrl;
    if (itemCache.has(keyMultiple)) {
        return itemCache.get(keyMultiple);
    }
    const items = fetchPcmData(`${baseUrl}/api/pcm/v3/${type}`, accessToken).then((r) => r.json());
    itemCache.set(keyMultiple, items);
    return items;
}
export function _invalidateCache(type, uuid, accessToken, baseUrl) {
    const keyMultiple = accessToken + "|" + type + "|" + baseUrl;
    if (itemCache.has(keyMultiple)) {
        itemCache.delete(keyMultiple);
    }
    if (uuid) {
        const keySingle = accessToken + "|" + type + "|" + uuid + "|" + baseUrl;
        if (itemCache.has(keySingle)) {
            itemCache.delete(keySingle);
        }
    }
}
/**
 * Gets a native PCM item by its id.
 *
 * @param type The item type, used in the url.
 * @returns The native PCM item with the given id.
 */
export async function _getPcmItem(type, id, accessToken, baseUrl) {
    checkAccessToken(accessToken);
    const uuid = _removeReadablePrefixFromUUID(id);
    // We first check if the item is in the cache for all items of the given type.
    // Only if it is not, we want to fetch the item directly.
    const keyMultiple = accessToken + "|" + type + "|" + baseUrl;
    if (itemCache.has(keyMultiple)) {
        const items = await itemCache.get(keyMultiple);
        const item = items.find((i) => i.id === uuid || i.alias === uuid);
        if (item) {
            return item;
        }
    }
    const keySingle = accessToken + "|" + type + "|" + uuid + "|" + baseUrl;
    if (itemCache.has(keySingle)) {
        return itemCache.get(keySingle);
    }
    const response = fetchPcmData(`${baseUrl}/api/pcm/v3/${type}/${id}`, accessToken);
    const item = response.then((res) => {
        if (res.status !== 200) {
            return undefined;
        }
        return res.json();
    });
    itemCache.set(keySingle, item);
    return item;
}
/**
 * Removes the potential readable prefix of the given id (e.g. alias_uuid)
 * If the given value does not end with a valid uuid the whole value is returned as is
 */
function _removeReadablePrefixFromUUID(id) {
    if (typeof id === "number") {
        return id; //The given id was a database id
    }
    if (id.length < 36) {
        return id;
    }
    const uuid = id.substring(id.length - 36);
    if (uuidValidate(uuid)) {
        return uuid;
    }
    return id;
}
