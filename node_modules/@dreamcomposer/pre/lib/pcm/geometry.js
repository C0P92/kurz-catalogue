import { getAccessToken } from "../methods/access-token.js";
import { getPcmBaseUrl } from "../methods/base-url.js";
import { isPcmItem, mapNativePcmItemToPcmItem, } from "./item.js";
import { _getPcmItem, _getPcmItems, _invalidateCache, checkAccessToken, } from "./util.js";
/**
 * Checks if the given object is a PcmGeometry.
 *
 * @param obj The object to check.
 * @returns True if the object is a PcmGeometry, false otherwise.
 */
export function isPcmGeometry(obj) {
    return (isPcmItem(obj) && "url" in obj && "defaultScale" in obj && "stages" in obj);
}
/**
 * Gets a list with all available geometries.
 *
 * @param accessToken The access token.
 * @param baseUrl The base url.
 * @returns A list with all available geometries.
 */
export async function getGeometries(accessToken = getAccessToken(), baseUrl = getPcmBaseUrl()) {
    const items = await _getPcmItems("geometries", accessToken, baseUrl);
    return items.map(mapNativePcmGeometryToPcmGeometry);
}
/**
 * Gets an geometry by its id.
 *
 * Using the id is not filtered (e.g., permissions, deprecations, etc.) and may
 * return elements that are not returned by {@link getGeometries}.
 *
 * @param id The id of the geometry.
 * @param accessToken The access token.
 * @param baseUrl The base url.
 * @returns The geometry with the given id or undefined if no geometry with the
 *          given id exists.
 */
export async function getGeometryById(id, accessToken = getAccessToken(), baseUrl = getPcmBaseUrl()) {
    const item = await _getPcmItem("geometries", id, accessToken, baseUrl);
    return item ? mapNativePcmGeometryToPcmGeometry(item) : undefined;
}
/**
 * Creates a new geometry with a given glTF 2.0 file and configuration.
 *
 * If the file or configuration is invalid a exception is thrown.
 *
 * After a successful creation the access right `PermissionRole.OWNER` is
 * automatically added to the newly created item
 *
 * @param temporaryFileId Reference of the uploaded glTF 2.0 file. It can be
 * obtained with the `validateGeometryFile()` function.
 * @param config The user defined configuration of the geometry.
 * @param accessToken The access token.
 * @param baseUrl The base url.
 * @returns The newly created geometry
 */
export async function createGeometry(temporaryFileId, config, accessToken = getAccessToken(), baseUrl = getPcmBaseUrl()) {
    checkAccessToken(accessToken);
    const pcmConfig = mapEditablePcmGeometryToNativeEditablePcmGeometry(config);
    const formData = { ...pcmConfig, temporaryFileId: temporaryFileId };
    const response = await fetch(`${baseUrl}/api/pcm/v3/geometries`, {
        method: "POST",
        headers: {
            "Content-Type": "application/json",
        },
        body: JSON.stringify(formData),
    });
    if (!response.ok) {
        throw new Error(`Failed to create geometry`);
    }
    _invalidateCache("geometries", undefined, accessToken, baseUrl);
    return response.json();
}
/**
 * Partially updates the values of the given geometry.
 *
 * This requires `PermissionRole.OWNER` access rights on the given item.
 * Otherwise a exception is thrown.
 *
 * @param geometryId The id of the geometry that should be modified
 * @param config The values that should be updated for the geometry
 * @param accessToken The access token.
 * @param baseUrl The base url.
 * @returns The updated geometry
 */
export async function patchGeometry(geometryId, config, accessToken = getAccessToken(), baseUrl = getPcmBaseUrl()) {
    checkAccessToken(accessToken);
    const response = await fetch(`${baseUrl}/api/pcm/v3/geometries/${geometryId}`, {
        method: "PATCH",
        headers: {
            "Content-Type": "application/json",
        },
        body: JSON.stringify(mapEditablePcmGeometryToNativeEditablePcmGeometry(config)),
    });
    if (!response.ok) {
        throw new Error(`Failed to patch geometry ${geometryId}`);
    }
    _invalidateCache("geometries", geometryId, accessToken, baseUrl);
    return mapNativePcmGeometryToPcmGeometry(await response.json());
}
/**
 * Permanently deletes the given geometry. This action can`t be reverted!
 *
 * This requires `PermissionRole.OWNER` access rights on the given item.
 * Otherwise a exception is thrown.
 *
 * @param geometry The geometry that should be deleted
 * @param accessToken The access token.
 * @param baseUrl The base url.
 * @returns `true` if the deletion was successful. Otherwise `false`
 */
export async function deleteGeometry(geometry, accessToken = getAccessToken(), baseUrl = getPcmBaseUrl()) {
    checkAccessToken(accessToken);
    try {
        const response = await fetch(`${baseUrl}/api/pcm/v3/geometries/${geometry.id}`, {
            method: "DELETE",
        });
        if (!response.ok) {
            throw new Error(`Failed to delete geometry ${geometry.id}`);
        }
        _invalidateCache("geometries", geometry.id, accessToken, baseUrl);
        return true;
    }
    catch {
        return false;
    }
}
const mapNativePcmGeometryToPcmGeometry = (geometry) => ({
    ...mapNativePcmItemToPcmItem(geometry),
    alias: geometry.alias,
    url: geometry.baseModelFile,
    iconUrl: geometry.iconUrl || undefined,
    defaultScale: geometry.defaultScale,
    scaleWithMapping: geometry.scaleWithMapping,
    supportsCutoutTextures: geometry.useCutoutTexture,
    stages: Object.keys(geometry.stages).map((stageId) => {
        const stage = geometry.stages[stageId];
        return {
            name: stageId,
            displayName: stage.name,
            normalVector: stage.normalVector,
            uvColor: stage.uvColor,
            axes: stage.axes,
            size: stage.size,
        };
    }),
    overrideConfig: geometry.overrideConfig,
});
const mapEditablePcmGeometryToNativeEditablePcmGeometry = (data) => {
    var _a;
    return ({
        name: data.displayName,
        description: data.description,
        stages: (_a = data.stages) === null || _a === void 0 ? void 0 : _a.reduce((config, stage) => ({
            ...config,
            [stage.name]: {
                name: stage.displayName,
                size: stage.size,
                normal_vector: stage.normalVector,
            },
        }), {}),
    });
};
