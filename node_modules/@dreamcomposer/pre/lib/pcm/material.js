import { getAccessToken } from "../methods/access-token.js";
import { getPcmBaseUrl } from "../methods/base-url.js";
import { isPcmItem, mapNativePcmItemToPcmItem, } from "./item.js";
import { _getPcmItem, _getPcmItems } from "./util.js";
import { isArray } from "lodash-es";
import color from "tinycolor2";
/**
 * Checks if the given object is a PcmMaterial.
 *
 * @param obj The object to check.
 * @returns True if the object is a PcmMaterial, false otherwise.
 */
export function isPcmMaterial(obj) {
    return isPcmItem(obj) && "previewColor" in obj && "definition" in obj;
}
/**
 * Checks if the given object is a PcmMaterialMinimalData.
 *
 * @param obj The object to check.
 * @returns True if the object is a PcmMaterialMinimalData, false otherwise.
 */
export function isPcmMaterialMinimalData(obj) {
    return (typeof obj === "object" &&
        obj !== null &&
        "definition" in obj &&
        "supportsOverprintContent" in obj &&
        "supportsOverprintColor" in obj &&
        "isVarnishMaterial" in obj &&
        "isPrintingMaterial" in obj &&
        "isSurfaceMaterial" in obj &&
        "overprintMode" in obj);
}
/**
 * Gets a list with all available materials.
 *
 * @param accessToken The access token.
 * @param baseUrl The base url.
 * @returns A list with all available materials.
 */
export async function getMaterials(accessToken = getAccessToken(), baseUrl = getPcmBaseUrl()) {
    const items = await _getPcmItems("materials", accessToken, baseUrl);
    return items.map(mapNativePcmMaterial);
}
/**
 * Gets an material by its id.
 *
 * Using the id is not filtered (e.g., permissions, deprecations, etc.) and may
 * return elements that are not returned by {@link getMaterials}.
 *
 * @param id The id of the material.
 * @param accessToken The access token.
 * @param baseUrl The base url.
 * @returns The material with the given id or undefined if no material with the
 *          given id exists.
 */
export async function getMaterialById(id, accessToken = getAccessToken(), baseUrl = getPcmBaseUrl()) {
    const item = await _getPcmItem("materials", id, accessToken, baseUrl);
    return item ? mapNativePcmMaterial(item) : undefined;
}
/**
 * @internal
 * Maps a native pcm material (as it is returned by the PCM API) to the
 * interface used for the user-facing definition.
 *
 * @param material The native material.
 * @returns The library pcm material.
 */
export function mapNativePcmMaterial(material) {
    const isOverprintable = material.tags.includes("feature:overprintable");
    const isTintable = material.tags.includes("feature:tintable");
    const isSpotColorable = material.tags.includes("feature:spotcolorable");
    const supportsPatternEmbossing = !material.tags.includes("feature:disable_pattern_embossing");
    return {
        ...mapNativePcmItemToPcmItem(material),
        alias: material.alias,
        previewColor: material.previewColor,
        supportsOverprintContent: isOverprintable,
        supportsOverprintColor: isTintable || isSpotColorable,
        supportsPatternEmbossing: supportsPatternEmbossing,
        isVarnishMaterial: material.tags.includes("material_type:varnish"),
        isPrintingMaterial: material.tags.includes("material_type:print"),
        isSurfaceMaterial: material.tags.includes("material_type:surface"),
        overprintMode: isTintable ? "tint" : isSpotColorable ? "opaque" : "none",
        definition: material.definition,
    };
}
/**
 * Returns the underlying base color of a given material
 * @param material
 * @returns
 */
export function getMaterialBaseColor(material) {
    const colorString = getMaterialBaseColorString(material);
    const c = color(colorString).toRgb();
    return { r: c.r, g: c.g, b: c.b };
}
function getMaterialBaseColorString(material) {
    const defaultColor = "#ffffff";
    let albedoColor = null;
    const materialDefinition = material.definition;
    if (materialDefinition != null &&
        typeof materialDefinition === "object" &&
        "materialOverrides" in materialDefinition) {
        const materialConfigs = materialDefinition["materialOverrides"];
        if (!isArray(materialConfigs)) {
            albedoColor = getAlbedoColorFromConfigEntry(materialConfigs);
        }
        if (isArray(materialConfigs)) {
            for (let i = materialConfigs.length - 1; i >= 0; i--) {
                albedoColor = getAlbedoColorFromConfigEntry(materialConfigs[i]);
                if (albedoColor != null) {
                    break;
                }
            }
        }
    }
    return albedoColor !== null && albedoColor !== void 0 ? albedoColor : defaultColor;
}
function getAlbedoColorFromConfigEntry(configEntry) {
    if (configEntry != null &&
        typeof configEntry === "object" &&
        "albedoColor" in configEntry) {
        const value = configEntry["albedoColor"];
        if (typeof value === "string") {
            return value;
        }
    }
    return null;
}
