/**
 * Passes mouse events from the embedder to the engine, since the iframe does
 * not receive mouse events outside of the iframe.
 *
 * @internal
 */
export class MouseEventHandler {
    constructor(dcController) {
        this.dcController = dcController;
        this.boundHandleMouseDown = this.handleMouseDown.bind(this);
        this.boundHandleMouseUp = this.handleMouseUp.bind(this);
        this.boundHandleMouseMove = this.handleMouseMove.bind(this);
    }
    addListeners() {
        window.addEventListener("mousedown", this.boundHandleMouseDown);
        window.addEventListener("mouseup", this.boundHandleMouseUp);
        window.addEventListener("mousemove", this.boundHandleMouseMove);
    }
    removeListeners() {
        window.removeEventListener("mousedown", this.boundHandleMouseDown);
        window.removeEventListener("mouseup", this.boundHandleMouseUp);
        window.removeEventListener("mousemove", this.boundHandleMouseMove);
    }
    // Events from the engine
    handlePointerEvent(event) {
        // We simulate mouse events on the container div when they happen inside
        // the iframe. This way, outside listeners (e.g. for closing popups on a
        // click outside) are notified.
        if (event.payload.type === "up") {
            const event = new MouseEvent("mouseup", {
                view: window,
                bubbles: true,
                cancelable: true,
            });
            this.dcController.container.dispatchEvent(event);
            // TODO: Instead of straight up removing the style from the body, we
            //  should remember the previous value and restore it.
            // TODO: Currently disabled because this can cause expensive style
            //  recalculations in Chrome. Needs more investigation.
            // window.document.body.style.pointerEvents = "";
            // this.dcController.innerContainer.style.pointerEvents = "auto";
        }
        if (event.payload.type === "down" || event.payload.type === "tap") {
            const event = new MouseEvent("mousedown", {
                view: window,
                bubbles: true,
                cancelable: true,
            });
            this.dcController.container.dispatchEvent(event);
            // When dragging inside the iframe and then moving the mouse outside of
            // the iframe, we do not want to have stuff like hover effects outside
            // TODO: Currently disabled because this can cause expensive style
            //  recalculations in Chrome. Needs more investigation.
            // window.document.body.style.pointerEvents = "none";
        }
    }
    handleMouseDown(event) {
        if (event.isTrusted) {
            this.sendEvent("mousedown", event);
            // Ensure that the iframe doesn't capture the mouse events when the user
            // is currently dragging something (e.g. a slider).
            this.dcController.innerContainer.style.pointerEvents = "none";
        }
    }
    handleMouseUp(event) {
        if (event.isTrusted) {
            this.sendEvent("mouseup", event);
            // Re-enable the iframe to capture mouse events.
            this.dcController.innerContainer.style.pointerEvents = "auto";
            // TODO: Instead of straight up removing the style from the body, we
            //  should remember the previous value and restore it.
            // TODO: Currently disabled because this can cause expensive style
            //  recalculations in Chrome. Needs more investigation.
            // window.document.body.style.pointerEvents = "";
        }
    }
    handleMouseMove(event) {
        if (event.isTrusted) {
            this.sendEvent("mousemove", event);
        }
    }
    sendEvent(type, event) {
        this.dcController.postMessage({
            channel: "mouse-events",
            payload: {
                type,
                clientX: event.clientX -
                    this.dcController.container.getBoundingClientRect().left,
                clientY: event.clientY -
                    this.dcController.container.getBoundingClientRect().top,
            },
        });
    }
}
